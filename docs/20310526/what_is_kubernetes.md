# 什么是 Kubernets?

这一页是关于 Kubernetes 的概览。

Kubernets 一个可移植，可扩展，开源的平台，用于管理容器化的工作负载和服务，促进可声明式的配置和自动化。拥有一个庞大的，快速发展的生态。K8s 的服务，支持和工具都是广泛可用的。

Kubernetes 这个名字来源于希腊语，意思是舵手或者飞行员。K8s 是 Kubernets 的缩写，因为 "K" 和 "s" 之间有 8 个字母。谷歌在 2014 年将 Kubernets 项目进行开源。Kubernets 结合了谷歌超过15年经验的生产运行工作负载和最佳规模的设计和社区的实践。

## 回到过去
让我们回到过去，看看为什么 Kubernets 如此有用
![](https://github.com/jackzhiii/JackZhiii/blob/main/images/k8s_evolution.svg)

1. **传统部署时代:** 在之前，组织运行应用程序在物理服务器上。那时候，没有办法在一个物理服务器上为应用程序定义资源边界，这导致了资源分配的问题。举个例子，如果多个应用程序运行在同一个物理服务器上，这可能导致一个应用程序的实例将会占用服务器大部分的资源，基于这种情况，同一个服务上的资源将会表现不佳。一个解决方法是将不同的应用程序运行在不同的物理服务器上。但是这样的扩展并没有充分利用资源，组织维护许多物理服务器的成本很高。

2. **虚拟化部署时代:** 作为一种解决方案，介绍以下虚拟化。它允许你在一个单物理服务器的 CPU 上运行多个虚拟机。


3. **容器化部署时代:** 容器类似于虚拟机，但是容器的隔离性没有虚拟机那么强，同时和操作系统上的应用程序共享操作系统。因此，容器被认为是轻量的。和虚拟机很相似，容器有它自己的文件系统，共享CPU，内存，进程空间以及更多的。因为容器可以和底层的基础设施进行解耦，因此容器的移植性可以跨云和操作系统发行版。

容器已经变得流行，是因为容器提供额外的好处，例如：
1. 敏捷应用程序创建和部署：相比较虚拟机镜像，提高了容器镜像的创建的便捷性和效率。

2. 持续发布，持续集成和发布：提供了可信赖和频繁的容器镜像构建和快速和高效回滚的发布。

3. 开发和运维关注点分离：在构建/发布时创建应用程序容器镜像，而不是部署时候创建，从而将应用程序和基础设施进行解耦。

4. 可观察性不仅表现在可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他信号。

5. 在开发，测试和生产环境保持环境一致性：让应用程序在笔记本和云上运行保持一致性。

6. 云上和操作系统发行版的可移植性：可以运行在 Ubuntu, RHEL, CoreOS, 主要的共有云之上，或者其他任何地方。

7. 以应用为中心管理：提高了抽象的级别，从虚拟硬件上运行一个操作到通过逻辑资源在操作系统上运行一个应用程序。

8. 松耦合，分布式的，弹性伸缩的，解放的微服务：应用程序被分解为更小，可以独立部署和动态管理 —— 而不是在一台大型单机上运行庞大的应用程序栈。

9. 资源隔离：可预测的应用程序性能

10. 资源利用：高效率利用资源

## 为什么你需要 K8s，以及用 K8s 能干什么
容器是一种好的方式来打包和运行你的应用程序。在一个生产环境中，你需要管理正在运行应用程序的容器，并且确保应用程序没有停机时间。举个例子，如果容器挂了，另外一个容器需要被启动。如果这种行为由系统来执行，不是更简单吗？

这就需要 Kubernets 来救援！K8s 为你提供一个框架来有弹性的运行分布式系统。它管理你的应用程序的扩展和故障切换，提供一种部署模式，以及更多的。举个例子, Kubernets 可以为你的系统简单的管理一个 canary 环境的部署。

K8s 可以为你做什么：
1. **服务发现和负载均衡:** Kubernetes 可以使用 DNS 名字 或者使用容器自己的 IP 地址来暴露一个容器。如果到一个容器的流量变高，Kubernetes 能够进行负载均衡，同时分发网络流量，因此部署将会稳定。

2. **存储编排:** K8s 允许你自动挂载一个你选择的文件系统，例如本地存储，公有云存储等等。

3. **自动部署和回滚:** 你可以 K8s 为你分发的容器描述你的期望状态, K8s 可以改变一个确切的状态到一个期望的状态在一个可控制的频率。举个例子，你可以自动化 Kubernetes 为部署创建新的容器，移除已存在的容器并且接收它们的资源到一个新的容器上。

4. **自动二进制打包:** 你提供 Kubernetes 一个集群化的节点，让这些节点可以运行容器化的任务。你告诉 Kubernetes 每个容器需要使用多少 CPU 和 内存。Kubernetes 可以将容器安装到您的节点上来最大的使用你资源。

5. **自我修复:** K8s 重新启动那些失败的容器，取代容器，杀掉那些没有响应用户自定义的健康检测，并且不再为客户端宣传它们知道相应的容器准备好接收服务。

6. **密钥和配置管理:** K8s 让你存储和管理敏感的信息，例如 密码，OAuth 同肯， SSH keys。你可以发布和更新密钥，应用程序配置而不需要重新构建容器的镜像，而不需要在配置栈中暴露密钥。

## Kubernetes 不是什么
Kubernetes 并不是传统的，全包含的 PaaS 系统。因为 K8s 操作的是容器级别的而不是硬件级别的，它提供了一些常见的PaaS产品普遍适用的特性，例如部署，扩展，负载均衡，并且集成用户日志，监控和警告方案。然而，K8s 并不是整体的，它的默认解决方案是可选的，插件化的。K8s 为构建开发者平台提供了构建块，但是保留了用户的选项和灵活性，这是非常重要的。

Kubernetes:
1. 不限制支持应用程序的类型。K8s的目标是支持各种各样的工作负载，包括无状态，有状态的，和数据处理的工作负载。如果应用程序可以运行在容器上，那么它在Kubernetes 会运行的良好。

2. 不部署源代码，并且不构建应用程序。持续集成，持续发布以及持续部署工作流取决于组织的文化和选择，同样的还是有技术栈的要求。

3. 不提供应用程序级别的服务，如中间件(例如消息总线), 数据处理框架(例如 Spark), 数据库(例如 MySQL), 缓存，同样不支持集群存储系统作为内置的服务。这些功能的组件可以运行在 K8s 上，或者可以通过可移植机制被运行在 K8s 上的应用程序访问，例如 [Open Service Broker](https://openservicebrokerapi.org/)

4. 不规定日志，监控和警报的解决方案。K8s 提供了一些集成的概念，以及收集和暴露指标的机制。

5. 不提供也不要求配置语言/系统(例如，jsonnet)。它提供了一种声明式的API，可以任意形式的声明性规范的目标。

6. 不提供也不采用任何全面的机器配置，管理，或自愈系统

7. 额外地，K8s 不仅仅是一个编排系统。实际上，它减少了编排的必要性。技术上对于编排的定义是执行定义的一个工作流：首先执行 A，然后执行 B， 最后执行 C。于此相反，Kubernetes 由一组独立的可组合的控制流组成，为了持续的驱动当前状态向提供的期望状态进步。它并不关系你是如何从A到C的过程。容器化的控制同样是不需要的。这导致一个系统更容易使用，高性能，有健壮性，有弹性和扩展性。
